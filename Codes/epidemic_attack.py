import numpy as np
import networkx as nx
import random
from copy import deepcopy
from multiprocessing import Pool
import math

class e_attack():
    def __init__(self, idp, SV, ac = 20, lmd = 2, atc = 1, ec = 1, fc_threshold=0.5, l=3):#idp->intrusion detection probability
        self.idp = idp
        self.SV =SV #random pick; node vulnerability as probability
        self.l = l
        self.ac = ac # ac->adaptation cycle(minutes)
        self.lmd = lmd # exponential(poisson) distribution parameter
        self.atc = atc# atc->attack cycle(minutes)
        self.ec = ec # ec->evaluation cycle(minutes)
        self.fc_threshold = 0.5 # evaluation threshold
        self.info = None

    def setup(self,g):
        self.g = g
        self.N = nx.number_of_nodes(g)
        self.event_threshold = int(self.fc_threshold * self.N)
        self.A = nx.to_numpy_matrix(g)
        self.na = nx.get_node_attributes(g, 'na')
        self.nc = nx.get_node_attributes(g, 'nc')
        self.nic = nx.get_node_attributes(g, 'nic') # number of identified attackers by IDS
        self.color = nx.get_node_attributes(g, 'c')
        
    def reset(self,A,nc,nic,na):
        self.g = nx.from_numpy_matrix(A)
        nx.set_node_attributes(self.g, nic, "nic")
        nx.set_node_attributes(self.g, nc, "nc")
        nx.set_node_attributes(self.g, na, "na")
        nx.set_node_attributes(self.g, self.color, "c")

    def seed(self, nc, na):
        initial_attackers = []
        attacker_candidates = []
        for i in range(self.N):
            if na[i] == 1:
                attacker_candidates.append(i)
        if len(attacker_candidates) == 0:
            return nc, initial_attackers
        for j in random.sample(attacker_candidates, min(len(attacker_candidates),np.random.poisson(lam=self.lmd, size=None))):
            r2 = random.random()
            d = self.SV[self.color[j]]
            if r2 <= d:
                nc[j] = 1
                initial_attackers.append(j)
        return nc, initial_attackers
    
    def time_main(self,record=False,seed=1):
        random.seed(seed)
        np.random.seed(seed)
        A = deepcopy(self.A)
        na = deepcopy(self.na)
        nc = deepcopy(self.nc)
        nic = deepcopy(self.nic)
        if self.info == None:
            spread = [0]*self.N
            sigma = np.zeros((self.N, self.l), dtype=int)
            latent_attackers = []
            attacker_list = [0]*self.N
            attackers = []
        else:
            spread, sigma, latent_attackers, attacker_list, attackers = self.info
        for step in range(self.ac):
            if step%self.atc == 0:
                nc, initial_attackers = self.seed(nc, na)
                attackers += initial_attackers
                #if record:
                    #print("attackers:",attackers)
                for i in attackers:
                    r1 = random.random()
                    if r1 > self.idp:
                        spread[i] = spread[i] + 1
                        for j in range(self.N):
                            if A[i,j] > 0 and nc[j] == 0:
                                if sigma[i,self.color[j]] == 1:
                                    nc[j] = attacker_list[j] = 1
                                    self.ce_list[i,j] += 1
                                    self.ce_list[j,i] += 1
                                    self.cn_list[i] += 1
                                else:
                                    r2 = random.random()
                                    d = self.SV[self.color[j]]
                                    if r2 <= d:
                                        nc[j] = attacker_list[j] = sigma[i,self.color[j]] = 1
                                        self.ce_list[i,j] += 1
                                        self.ce_list[j,i] += 1
                                        self.cn_list[i] += 1
                    else:
                        na[i] = 0
                        #nic[i] = 1
                        attacker_list[i] = 0
                        A[i,:] = A[:,i] = 0
                    if spread[i] == 2:
                        na[i] = 0
                        attacker_list[i] = 0
                        latent_attackers.append(i)
                attackers = [i for i in range(self.N) if attacker_list[i] == 1]
                for i in latent_attackers:
                    A[i,:] = A[:,i] = 0
            if record and step%self.ec == 0:
                active_attackers = 0
                for i in range(self.N):
                    if nc[i] == 1 and na[i] == 1:
                        active_attackers += 1
                self.record.append([sum(nc.values())/float(self.N), len(max(nx.connected_components(nx.from_numpy_matrix(A)), key=len))/float(self.N),active_attackers/(sum(na.values())+1e-8)])
        if record:
            self.reset(A,nc,nic,na)
            self.info = spread, sigma, latent_attackers, attacker_list, attackers
        return sum(nc.values()), len(max(nx.connected_components(nx.from_numpy_matrix(A)), key=len))
    
    def event_main(self,record=False):
        A = deepcopy(self.A)
        na = deepcopy(self.na)
        nc = deepcopy(self.nc)
        nic = deepcopy(self.nic)
        spread = [0]*self.N
        sigma = np.zeros((self.N, self.l), dtype=int)
        latent_attackers = []
        attacker_list = [0]*self.N
        attackers = []
        step = 0
        while sum(nic.values())<=self.event_threshold:
            if step%self.atc == 0:
                nc, initial_attackers = self.seed(nc, na)
                attackers += initial_attackers
                for i in attackers:
                    r1 = random.random()
                    if r1 > self.idp:
                        spread[i] = spread[i] + 1
                        for j in range(self.N):
                            if A[i,j] > 0 and nc[j] == 0:
                                if sigma[i,self.color[j]] == 1:
                                    nc[j] = attacker_list[j] = 1
                                    self.ce_list[i,j] += 1
                                    self.ce_list[j,i] += 1
                                    self.cn_list[i] += 1
                                else:
                                    r2 = random.random()
                                    d = self.SV[self.color[j]]
                                    if r2 <= d:
                                        nc[j] = attacker_list[j] = sigma[i,self.color[j]] = 1
                                        self.ce_list[i,j] += 1
                                        self.ce_list[j,i] += 1
                                        self.cn_list[i] += 1
                    else:
                        na[i] = 0
                        nic[i] = 1
                        attacker_list[i] = 0
                        A[i,:] = A[:,i] = 0
                    if spread[i] == 2:
                        na[i] = 0
                        attacker_list[i] = 0
                        latent_attackers.append(i)
                attackers = [i for i in range(self.N) if attacker_list[i] == 1]
                for i in latent_attackers:
                    A[i,:] = A[:,i] = 0
            step += 1
            if record and step%self.ec == 0:
                self.record.append([sum(nc.values())/float(self.N), len(max(nx.connected_components(nx.from_numpy_matrix(A)), key=len))/float(self.N)])
        if record:
            self.reset(A,nc,nic,na)
            self.info = spread, sigma, latent_attackers, attacker_list, attackers
        return sum(nc.values()), len(max(nx.connected_components(nx.from_numpy_matrix(A)), key=len))
    
    def eval_single(self, times, g, mode='time', record=False, multi=False,seed=1):
        self.setup(g)
        self.ce_list = np.zeros((self.N,self.N),dtype=int)
        self.cn_list = np.zeros((self.N,),dtype=int)
        if mode == 'time':
            self.mtd = self.time_main
        elif mode == 'event':
            self.mtd = self.event_main
        if record:
            self.record = [] # record evaluation snapshots
            cn, largest_cc = self.mtd(record=True,seed=seed)
            return self.record, deepcopy(self.g)
        else:
            if multi:
                cn, largest_cc = self.multi_eval(times, process_num = 24)
            else:
                cn, largest_cc = self.single_eval(times)
            return cn/(times*float(self.N)), largest_cc/(times*float(self.N)), self.ce_list, self.cn_list
        
    def single_eval(self, times):
        cn = 0
        largest_cc = 0
        for t in range(times):
            temp_fc, temp_sgc = self.mtd(record=False,seed=t)
            cn += temp_fc
            largest_cc += temp_sgc
        return cn, largest_cc
        
    def multi_eval(self, sim_num, process_num = 24):
        temp = math.floor(sim_num/process_num)
        remain = sim_num-temp*process_num
        if remain > 0:
            process_num += 1
            input_array = [temp for i in range(process_num)] + [remain]
        else:
            input_array = [temp for i in range(process_num)]
        #print(input_array)
        input_array = [[i] for i in input_array]
        pool = Pool()
        #print("Separated results:")
        results = pool.starmap(self.single_eval, input_array)
        pool.close()
        pool.join()
        results = [np.sum([results[i][j] for i in range(process_num)]) for j in range(2)]
        return results
    
def SV(x,l):
    return [x/(l+1)*i for i in range(1,l+1)]
