import numpy as np
import networkx as nx
from copy import deepcopy
from operator import itemgetter, attrgetter

class Agent(object):
    def __init__(self, g, attack, a_times=1000):
        self.g = g
        self.na = nx.get_node_attributes(g, 'na')
        self.attack = attack
        self.attack_times = a_times
        self.num_edges = nx.number_of_edges(self.g)
        self.num_nodes = nx.number_of_nodes(self.g)
        self.A=nx.to_numpy_matrix(g)
        self.fc, self.sgc, self.ce_list, self.cn_list = self.attack.eval_single(self.attack_times,deepcopy(self.g),multi=True)
        self.e_rank = []
        for i in range(self.num_nodes-1):
            for j in range(i+1,self.num_nodes):
                if self.A[i,j] == 1:
                    self.e_rank.append([i,j,self.ce_list[i,j]])
        self.e_rank = sorted(self.e_rank, key=itemgetter(2), reverse=True)
        self.cut_list = dict()
        self.cut_result = dict()
        self.cut_list[0] = self.cn_list
        self.cut_result[0] = self.sgc - self.fc

    def add(self, cn_list, budget, temp_g, A):          
        n_rank = []
        n_list = []
        for i in range(self.num_nodes):
            if self.na[i]==1:
                n_rank.append([i,cn_list[i]])
        n_rank = sorted(n_rank, key=itemgetter(1), reverse=False)
        n_list += [n[0] for n in n_rank]
        ebunch = []
        gc = max(nx.connected_components(temp_g), key=len)
        b0=0
        if len(gc)<self.num_nodes:
            n_list_gc, n_list_ngc = [], [] 
            for x in n_list:
                if x in gc:
                    n_list_gc.append(x)
                else:
                    n_list_ngc.append(x)
            b0 = min(budget,len(n_list_ngc))
            for i in n_list_ngc:
                for j in n_list_gc:
                    if A[i,j] == 0:
                        ebunch.append([i,j])
                        A[i,j] = A[j,i] = 1
                        break
                    #if len(ebunch)>budget-1:
                        #break
                #if len(ebunch)>budget-1:
                    #break
        if b0<budget:
            for i in range(1,len(n_list)-1):
                for j in range(i):
                    if A[n_list[i],n_list[j]]==0:
                        ebunch.append([n_list[i],n_list[j]])
                        A[n_list[i],n_list[j]] = A[n_list[j],n_list[i]] = 1
                        if len(ebunch)>budget-1:
                            break
                    if len(ebunch)>budget-1:
                        break
                if len(ebunch)>budget-1:
                    break        
        return ebunch,A
    
    def eval_all(self,budget,get_graph=False,multi=False):
        bc, ba = budget
        self.temp_A = deepcopy(self.A)
        self.temp_g = deepcopy(self.g)
        ebunch=[e[:2] for e in self.e_rank[:bc]]
        for i,j in ebunch:
            self.temp_A[i,j] = self.temp_A[j,i] = 0
        self.temp_g.remove_edges_from(ebunch)
        try:
            self.cn_list = self.cut_list[bc]            
        except KeyError:
            fc2, sgc2, _, self.cn_list = self.attack.eval_single(self.attack_times,self.temp_g,multi=multi)
            self.cut_list[bc] = self.cn_list
            self.cut_result[bc] = sgc2 - fc2
        #if ba == 0:
            #if get_graph:
                #return deepcopy(self.temp_g)
            #return self.cut_result[bc]            
        ebunch,A = self.add(self.cn_list,ba, self.temp_g,self.temp_A)
        self.temp_g.add_edges_from(ebunch)
        if get_graph:
            return deepcopy(self.temp_g)
        fc3, sgc3, _, _ = self.attack.eval_single(self.attack_times,self.temp_g,multi=multi)
        #return fc3,sgc3,sgc3 - fc3
        return sgc3 - fc3
